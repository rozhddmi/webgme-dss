/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.16.0 from webgme on Tue Jan 30 2018 10:13:19 GMT-0600 (Central Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'common/core/users/merge'
], function (PluginConfig,
             pluginMetadata,
             PluginBase,
             merger) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of DomainSelector.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin DomainSelector.
     * @constructor
     */
    function DomainSelector() {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    }

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    DomainSelector.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    DomainSelector.prototype = Object.create(PluginBase.prototype);
    DomainSelector.prototype.constructor = DomainSelector;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    DomainSelector.prototype.main = function (callback) {
        let config = this.getCurrentConfig(),
            core = this.core,
            logger = this.logger,
            domains = config.domains.split(':'),
            commitMessage = 'Domain updated to include: ',
            newLanguageHash;

        core.loadInstances(this.META.Domain)
            .then((domainNodes) => {

                domainNodes.forEach(domainNode => {
                    let domainName = core.getAttribute(domainNode, 'name');
                    if (domains.includes(domainName)) {
                        logger.info('Domain will be kept', domainName);
                        commitMessage += domainName + ' '
                    } else {
                        logger.info('Domain will be REMOVED', domainName);
                        core.deleteNode(domainNode);
                    }
                });

                // FIXME: This is a temporary fix when no changes..
                let tick = core.getRegistry(this.rootNode, 'tick') || 0;
                core.setRegistry(this.rootNode, 'tick', tick + 1);

                // Make a head-less commit from the "full domain" with the unused domains filtered out.
                let persisted = core.persist(this.rootNode);
                return this.project.makeCommit(null, [this.currentHash], persisted.rootHash, persisted.objects,
                    commitMessage);
            })
            .then((commitResult) => {
                newLanguageHash = commitResult.hash;
                // Tag the new commit so it can act as the "baseHash" for next language update.
                return this.project.createTag(config.tagName, newLanguageHash);
            })
            .then(() => {
                // Compute a patch with the difference the new language and the previous one (baseHash).
                return merger.diff({
                    gmeConfig: this.gmeConfig,
                    logger: logger,
                    project: this.project,
                    branchOrCommitA: config.baseHash,
                    branchOrCommitB: newLanguageHash
                });
            })
            .then((patch) => {
                logger.info('Created patch object', JSON.stringify(patch, null, 2));
                // Apply that patch to master branch
                return merger.apply({
                    gmeConfig: this.gmeConfig,
                    logger: logger,
                    project: this.project,
                    patch: patch,
                    branchOrCommit: this.branchName,
                    branchName: this.branchName,
                    msg: commitMessage
                });
            })
            .then((commitResult) => {
                if (commitResult.status !== this.project.CONSTANTS.SYNCED) {
                    throw new Error('Failed to update branch with new language');
                }

                this.result.addCommit({
                    commitHash: commitResult.hash,
                    branchName: this.branchName,
                    status: commitResult.status
                });
                this.result.setSuccess(true);

                callback(null, this.result);
            })
            .catch((err) => {
                // Result success is false at invocation.
                callback(err, this.result);
            });
    };

    return DomainSelector;
});
